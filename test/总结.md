###1.文件读写
所以我们可以得知，go语言中读取文件的三种方法。
![](images/fileread.png)
1. 读文件
第一种，我们可以使用切片的形式，定制一次读取文件的多少字节并用for循环来读取文件的内容。<br>
第二种，我们可以使用go语言内置的buffio包来一行一行的读取文件的内容。<br>
第三种，我们可以使用go语言内置的ioutil包来读取整个文件的所有内容。<br>
一次性读取所有的数据，太耗费内存，因此可以指定每次只读取一行数据。方法有三种：

bufio.ReadLine()
bufio.ReadBytes('\n')
bufio.ReadString('\n')
在 bufio 的源码注释中，曾说道 bufio.ReadLine() 是低级库，不太适合普通用户使用，更推荐用户使用 bufio.ReadBytes 和 bufio.ReadString 去读取单行数据。
2. 打开文件
第一种 os.Open() 只读形式打开文件
第二种 os.OpenFile()函数能够以指定模式打开文件，从而实现文件写入相关功能
``` os.O_CREATE:创建
    //os.O_WRONLY:只写
     
     //os.O_APPEND:追加
     //os.O_RDONLY:只读
     //os.O_RDWR:读写
     //os.O_TRUNC:清空
  
     //0644:文件的权限 
```

3.写文件
1. 写字符串 WriteString("\n") 
2. 写[]byte str := "你好啊\n" file.Write([]byte(str))
3. bufio.NewWriter    循环写文件
    ```writer := bufio.NewWriter(file) //往文件里面写入内容，得到了一个writer对象
           for i := 0; i <10; i++ { //循环写入10行
               writer.WriteString("test\n") //将数据写入缓存
           } 
4. ioutil.WriteFile 整个写文件
``` str := "Hello Golang！"
        err := ioutil.WriteFile("./ioutil.txt",[]byte(str),0664)//接收文件名，字节类型的数据，文件的权限
        if err != nil{
            fmt.Printf("打开文件失败,错误为:%v\n",err)
            return
        } 
```` 
### 2.面向对象
2.1  结构体
* 规则一：当最后一个字段和结果不在同一行时，, 不可省略 反之，不在同一行，就可以省略。

```cassandraql
xm := Profile{
    name: "小明",
    age: 18,
    gender: "male",
}

xm := Profile{
    name: "小明",
    age: 18,
    gender: "male"}
```
* 规则二：字段名要嘛全写，要嘛全不写，不能有的写，有的不写。
* 规则三：初始化结构体，并不一定要所有字段都赋值，未被赋值的字段，会自动赋值为其类型的零值。
2.2 方法定义
以值做为方法接收者
以指针做为方法接收者
2.3 实例化
1. 第一种：正常实例化
```
func main() {
    xm := Profile{
        name: "小明",
        age: 18,
        gender: "male",
    }
}
```
2. 使用new 
```cassandraql

func main() {
    xm := new(Profile)
    // 等价于: var xm *Profile = new(Profile)
    fmt.Println(xm)
    // output: &{ 0 }

    xm.name = "iswbm"   // 或者 (*xm).name = "iswbm"
    xm.age = 18     //  或者 (*xm).age = 18
    xm.gender = "male" // 或者 (*xm).gender = "male"
    fmt.Println(xm)
    //output: &{iswbm 18 male}
}
```
3. 使用 &
```cassandraql

func main() {
    var xm *Profile = &Profile{}
    fmt.Println(xm)
    // output: &{ 0 }

    xm.name = "iswbm"   // 或者 (*xm).name = "iswbm"
    xm.age = 18     //  或者 (*xm).age = 18
    xm.gender = "male" // 或者 (*xm).gender = "male"
    fmt.Println(xm)
     //output: &{iswbm 18 male}
}
```
#### 2.1 断言
类型断言，仅能对静态类型为空接口（interface{}）的对象进行断言，否则会抛出错误，具体内容可以参考：关于接口的三个”潜规则”

类型断言完成后，实际上会返回静态类型为你断言的类型的对象，而要清楚原来的静态类型为空接口类型（interface{}），这是 Go 的隐式转换。


### 3.反射
#### 3.1 Reflection goes from interface value to reflection object.
1. reflect.TypeOf(i) ：获得接口值的类型
2. reflect.ValueOf(i)：获得接口值的值

new：为所有的类型分配内存，并初始化为零值，返回指针。

make：只能为 slice，map，chan 分配内存，并初始化，返回的是类型
### 4.空结构体

### 5.包导入
### 6.函数
1.Go支持返回带有变量名的值
```cassandraql
func double(a int) (b int) {
    // 不能使用 := ,因为在返回值哪里已经声明了为int
 b = a * 2
    // 不需要指明写回哪个变量,在返回值类型那里已经指定了
 return
}
func main() {
 fmt.Println(double(2))
}
// output: 4

```

### 7.协程
 go mygo("协程1号")  启动一个协程
 
 ### 8. channel
  channel（信道） 就是 协程的并发机制，通信的通道
  // 定义信道
  pipline := make(chan int)
  
  <-chan 表示这个信道，只能从里发出数据，对于程序来说就是只读
  
  chan<- 表示这个信道，只能从外面接收数据，对于程序来说就是只写
  
#### 8.1. 用信道来做锁

利用通道一读一写的机制，必须设置通道量为 1 
// 注意要设置容量为 1 的缓冲信道
	pipline := make(chan bool, 1)

几个注意事项
关闭一个未初始化的 channel 会产生 panic
重复关闭同一个 channel 会产生 panic
向一个已关闭的 channel 发送消息会产生 panic
从已关闭的 channel 读取消息不会产生 panic，且能读出 channel 中还未被读取的消息，若消息均已被读取，则会读取到该类型的零值。
从已关闭的 channel 读取消息永远不会阻塞，并且会返回一个为 false 的值，用以判断该 channel 是否已关闭（x,ok := <- ch）
关闭 channel 会产生一个广播机制，所有向 channel 读取消息的 goroutine 都会收到消息
channel 在 Golang 中是一等公民，它是线程安全的，面对并发问题，应首先想到 channel。
### 9.WaitGroup
